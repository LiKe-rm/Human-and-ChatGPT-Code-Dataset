#include <iostream>
#include <string>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <atomic>
#include <fstream>
#include <algorithm>
#include <memory>

#include <curl/curl.h>

std::queue<std::string> upload_queue;
std::mutex queue_mutex;
std::condition_variable queue_cv;
std::atomic<bool> exit_flag{false};
constexpr int THREAD_COUNT = 4;
std::atomic<int> active_thread_count{0};

bool is_killswitch(const std::string &path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) {
        return false;
    }
    char buffer[8];
    file.read(buffer, 8);
    file.close();
    std::string magic(buffer, 8);
    return magic == "KILLPROC";
}

CURLcode create_remote_directory(CURL *curl, const std::string &directory_path) {
    CURLcode result;
    char curl_error[CURL_ERROR_SIZE];
    
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_error);
    curl_easy_setopt(curl, CURLOPT_URL, directory_path.c_str());
    curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR);
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    result = curl_easy_perform(curl);

    if (result != CURLE_OK) {
        std::cerr << "Failed to create directory: " << curl_error << std::endl;
    }
    
    return result;
}

void upload_thread_entry() {
    active_thread_count++;
    while (!exit_flag) {
        std::unique_lock<std::mutex> lock(queue_mutex);
        queue_cv.wait(lock, [] { return !upload_queue.empty() || exit_flag; });

        if (exit_flag) {
            break;
        }

        std::string file_path = upload_queue.front();
        upload_queue.pop();
        lock.unlock();

        if (is_killswitch(file_path)) {
            exit_flag = true;
            break;
        }

        // Upload the file using cURL
        CURL *curl = curl_easy_init();
        if (!curl) {
            std::cerr << "Failed to initialize cURL" << std::endl;
            continue;
        }

        // Create remote directory
        std::string remote_directory = "ftp://ftp.example.com/path/to/directory/";
        create_remote_directory(curl, remote_directory);

        // Upload file
        std::string remote_file_path = remote_directory + file_path;
        std::FILE *file = std::fopen(file_path.c_str(), "rb");
        if (!file) {
            std::cerr << "Failed to open file: " << file_path << std::endl;
            curl_easy_cleanup(curl);
            continue;
        }

        curl_easy_setopt(curl, CURLOPT_URL, remote_file_path.c_str());
        curl_easy_setopt(curl, CURLOPT_READDATA, file);
        curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
        CURLcode result = curl_easy_perform(curl);

        if (result != CURLE_OK) {
            std::cerr << "Failed to upload file: " << file_path << std::endl;
        }

        std::fclose(file);
        curl_easy_cleanup(curl);
    }

    active_thread_count--;
}

CURL *connect_ftp(const std::string &address, int port, const std::string &username, const std::string &password) {
    CURL *curl = curl_easy_init();
    if (!curl) {
        std::cerr << "Failed to initialize cURL" << std::endl;
        return nullptr;
    }

    std::string url = "ftp://" + address + ":" + std::to_string(port) + "/";
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_USERNAME, username.c_str());
    curl_easy_setopt(curl, CURLOPT_PASSWORD, password.c_str());
    curl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, 1L);
    CURLcode result = curl_easy_perform(curl);
    if (result != CURLE_OK) {
        std::cerr << "Failed to connect to FTP server: " << curl_easy_strerror(result) << std::endl;
        curl_easy_cleanup(curl);
        return nullptr;
    }

    return curl;
}

void enqueue_file(const std::string &file_path) {
    std::unique_lockstd::mutex lock(queue_mutex);
    upload_queue.push(file_path);
    lock.unlock();
    queue_cv.notify_one();
}

void wait_for_threads() {
    while (active_thread_count > 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main() {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    CURL *curl = connect_ftp("ftp.example.com", 21, "username", "password");
    if (!curl) {
        curl_global_cleanup();
        return 1;
    }

    std::vector<std::thread> threads;
    for (int i = 0; i < THREAD_COUNT; ++i) {
        threads.emplace_back(upload_thread_entry);
    }

    enqueue_file("path/to/file1.txt");
    enqueue_file("path/to/file2.txt");
    enqueue_file("path/to/file3.txt");

    wait_for_threads();

    curl_easy_cleanup(curl);
    curl_global_cleanup();

    return 0;
}

