#include <iostream>
#include <fstream>
#include <vector>
#include <Windows.h>

bool load_PE_file(const char* filename, void*& module_base, size_t& module_size);
DWORD WINAPI start_executable(LPVOID base_address);

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cout << "Usage: " << argv[0] << " <PE file path>" << std::endl;
        return 1;
    }

    void* module_base = nullptr;
    size_t module_size = 0;

    if (!load_PE_file(argv[1], module_base, module_size)) {
        std::cerr << "Failed to load PE file: " << argv[1] << std::endl;
        return 1;
    }

    DWORD thread_id;
    HANDLE hThread = CreateThread(nullptr, 0, start_executable, module_base, 0, &thread_id);

    if (hThread == nullptr) {
        std::cerr << "Failed to create thread" << std::endl;
        return 1;
    }

    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    VirtualFree(module_base, 0, MEM_RELEASE);
    return 0;
}

bool load_PE_file(const char* filename, void*& module_base, size_t& module_size) {
    std::ifstream file(filename, std::ios::binary | std::ios::ate);

    if (!file.is_open()) {
        return false;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> file_data(size);
    if (!file.read(file_data.data(), size)) {
        return false;
    }

    file.close();

    PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)file_data.data();
    if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) {
        return false;
    }

    PIMAGE_NT_HEADERS nt_headers = (PIMAGE_NT_HEADERS)(file_data.data() + dos_header->e_lfanew);
    if (nt_headers->Signature != IMAGE_NT_SIGNATURE) {
        return false;
    }

    PVOID image_base = (PVOID)nt_headers->OptionalHeader.ImageBase;
    DWORD image_size = nt_headers->OptionalHeader.SizeOfImage;
    module_size = image_size;

    module_base = VirtualAlloc(image_base, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!module_base) {
        return false;
    }

    DWORD headers_size = nt_headers->OptionalHeader.SizeOfHeaders;
    memcpy(module_base, file_data.data(), headers_size);

    PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)(file_data.data() + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i, ++section_header) {
        PVOID section_base = (PBYTE)module_base + section_header->VirtualAddress;
        memcpy(section_base, file_data.data() + section_header->PointerToRawData, section_header->SizeOfRawData);
    }

    // Fix relocations
    PIMAGE_DATA_DIRECTORY reloc_dir = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if (reloc_dir->Size) {
        PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((PBYTE)module_base + reloc_dir->VirtualAddress);
        while (reloc->SizeOfBlock) {
            size_t entries_num = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            PWORD reloc_entry = (PWORD)(reloc + 1);
            for (size_t i = 0; i < entries_num; ++i, ++reloc_entry) {
                DWORD reloc_type = *reloc_entry >> 12;
                if (reloc_type == IMAGE_REL_BASED_HIGHLOW || reloc_type == IMAGE_REL_BASED_DIR64) {
                    size_t offset = *reloc_entry & 0xFFF;
                    PDWORD64 patch_address = (PDWORD64)((PBYTE)module_base + reloc->VirtualAddress + offset);
                    *patch_address += (size_t)module_base - (size_t)image_base;
                }
            }
            reloc = (PIMAGE_BASE_RELOCATION)((PBYTE)reloc + reloc->SizeOfBlock);
        }
    }

    // Fix imports
    PIMAGE_DATA_DIRECTORY import_dir = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    if (import_dir->Size) {
        PIMAGE_IMPORT_DESCRIPTOR import_desc = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)module_base + import_dir->VirtualAddress);
        while (import_desc->Name) {
            PCHAR dll_name = (PCHAR)((PBYTE)module_base + import_desc->Name);
            HMODULE hDll = LoadLibraryA(dll_name);

            if (!hDll) {
                VirtualFree(module_base, 0, MEM_RELEASE);
                return false;
            }

            PIMAGE_THUNK_DATA orig_first_thunk = (PIMAGE_THUNK_DATA)((PBYTE)module_base + import_desc->OriginalFirstThunk);
            PIMAGE_THUNK_DATA first_thunk = (PIMAGE_THUNK_DATA)((PBYTE)module_base + import_desc->FirstThunk);

            while (orig_first_thunk->u1.AddressOfData) {
                if (orig_first_thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
                    size_t ordinal = orig_first_thunk->u1.Ordinal & 0xFFFF;
                    first_thunk->u1.Function = (size_t)GetProcAddress(hDll, MAKEINTRESOURCEA(ordinal));
                } else {
                    PIMAGE_IMPORT_BY_NAME import_by_name = (PIMAGE_IMPORT_BY_NAME)((PBYTE)module_base + orig_first_thunk->u1.AddressOfData);
                    first_thunk->u1.Function = (size_t)GetProcAddress(hDll, import_by_name->Name);
                }

                ++orig_first_thunk;
                ++first_thunk;
            }

            ++import_desc;
        }
    }

    // Set executable section permissions
    section_header = (PIMAGE_SECTION_HEADER)(file_data.data() + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i, ++section_header) {
        if (section_header->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            PVOID section_base = (PBYTE)module_base + section_header->VirtualAddress;
            DWORD old_protect;
            VirtualProtect(section_base, section_header->SizeOfRawData, PAGE_EXECUTE_READ, &old_protect);
        }
    }

    return true;
}

DWORD WINAPI start_executable(LPVOID base_address) {
    PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)base_address;
    PIMAGE_NT_HEADERS nt_headers = (PIMAGE_NT_HEADERS)((PBYTE)base_address + dos_header->e_lfanew);
    PVOID entry_point = (PVOID)((PBYTE)base_address + nt_headers->OptionalHeader.AddressOfEntryPoint);

    auto main_function = (int(__stdcall*)(void))entry_point;
    return main_function();
}

