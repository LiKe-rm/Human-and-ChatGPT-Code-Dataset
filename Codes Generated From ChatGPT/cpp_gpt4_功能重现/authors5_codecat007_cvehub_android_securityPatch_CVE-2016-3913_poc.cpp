#include <iostream>
#include <string>
#include <memory>
#include <android/media/IMediaPlayer.h>
#include <android/media/IMediaPlayerService.h>
#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>

using namespace android;
using namespace std;

// MyMediaPlayer 类
class MyMediaPlayer : public BnMediaPlayer {
public:
    MyMediaPlayer() {
        cout << "MyMediaPlayer() 构造函数" << endl;
    }

    ~MyMediaPlayer() {
        cout << "~MyMediaPlayer() 析构函数" << endl;
    }

    status_t setDataSource(const sp<IMediaHTTPService> &httpService,
                           const char *url,
                           const KeyedVector<String8, String8> *headers) {
        cout << "设置数据源: " << url << endl;
        return NO_ERROR;
    }

    status_t prepareAsync() {
        cout << "异步准备" << endl;
        return NO_ERROR;
    }

    status_t start() {
        cout << "开始播放" << endl;
        return NO_ERROR;
    }

    status_t stop() {
        cout << "停止播放" << endl;
        return NO_ERROR;
    }

    status_t pause() {
        cout << "暂停播放" << endl;
        return NO_ERROR;
    }

    status_t setNextMediaPlayer(const sp<IMediaPlayer> &next) {
        cout << "设置下一个播放器" << endl;
        return NO_ERROR;
    }
};

int main() {
    cout << "开始执行程序" << endl;

    sp<IServiceManager> sm = defaultServiceManager();
    sp<IBinder> binder = sm->getService(String16("media.player"));

    // 注意: 这里有一个漏洞，将 BpMediaPlayer 对象强制转换为 MediaPlayerService::Client 对象时，会造成越界访问。
    sp<MediaPlayerService::Client> client = static_cast<MediaPlayerService::Client *>(binder.get());

    sp<MyMediaPlayer> localPlayer = new MyMediaPlayer();
    sp<IMediaPlayer> player = localPlayer->create();

    if (player == NULL) {
        cout << "创建媒体播放器失败" << endl;
        return -1;
    }

    // 初始化 player 对象
    player->setDataSource(NULL, "http://example.com/media.mp3", NULL);
    player->prepareAsync();
    player->start();

    sleep(5); // 模拟播放5秒

    player->stop();
    player->setNextMediaPlayer(localPlayer);

    cout << "程序执行结束" << endl;
    return 0;
}
