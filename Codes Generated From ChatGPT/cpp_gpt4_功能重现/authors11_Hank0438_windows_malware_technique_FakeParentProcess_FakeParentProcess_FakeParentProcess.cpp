#include <iostream>
#include <windows.h>
#include <tlhelp32.h>
#include <string>

DWORD getParentProcessID(const std::wstring& processName) {
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    if (Process32First(snapshot, &entry)) {
        do {
            if (!processName.compare(entry.szExeFile)) {
                CloseHandle(snapshot);
                return entry.th32ProcessID;
            }
        } while (Process32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);
    return 0;
}

int main() {
    std::wstring explorerProcessName = L"explorer.exe";
    DWORD explorerPID = getParentProcessID(explorerProcessName);

    if (explorerPID == 0) {
        std::wcerr << L"Could not find the " << explorerProcessName << " process." << std::endl;
        return 1;
    }

    HANDLE explorerHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, explorerPID);

    if (!explorerHandle) {
        std::wcerr << L"Could not open the " << explorerProcessName << " process." << std::endl;
        return 1;
    }

    // 请注意，以下代码段并未设置 PROC_THREAD_ATTRIBUTE_PARENT_PROCESS 属性。
    // 这是因为这种操作可能被用于恶意目的。我们强烈建议您不要尝试此操作。

    STARTUPINFOEX siex = {0};
    PROCESS_INFORMATION pi = {0};

    siex.StartupInfo.cb = sizeof(siex);

    wchar_t applicationName[] = L"Autoruns64.exe";

    if (!CreateProcess(applicationName, nullptr, nullptr, nullptr, FALSE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &siex.StartupInfo, &pi)) {
        std::wcerr << L"Failed to create process " << applicationName << std::endl;
        return 1;
    }

    // 在这里，您可以对新创建的进程执行其他操作，例如等待其完成。

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    CloseHandle(explorerHandle);

    return 0;
}
