#include <iostream>
#include <windows.h>

typedef void (*WINEXEC_SHELLCODE)();

int main() {
    // 定义启动计算器的shellcode
    unsigned char shellcode[] = {
        0x50, 0x51, 0x52, 0x31, 0xc0, 0xb8, 0x50, 0xd7, 0x75, 0x77, 0xff, 0xd0,
        0x68, 0x63, 0x61, 0x6c, 0x63, 0x89, 0xe2, 0x52, 0x52, 0x53, 0x89, 0xe1,
        0x31, 0xd2, 0x52, 0x51, 0x52, 0x31, 0xc0, 0xb8, 0x2d, 0x06, 0x95, 0x7c,
        0xff, 0xd0, 0x5a, 0x59, 0x58
    };

    // 获取当前进程的句柄
    HANDLE processHandle = GetCurrentProcess();

    // 分配内存
    LPVOID allocatedMemory = VirtualAllocEx(
        processHandle,
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    if (allocatedMemory == NULL) {
        std::cerr << "Memory allocation failed." << std::endl;
        return -1;
    }

    // 将shellcode拷贝到分配的内存中
    BOOL writeResult = WriteProcessMemory(
        processHandle,
        allocatedMemory,
        shellcode,
        sizeof(shellcode),
        NULL);

    if (!writeResult) {
        std::cerr << "Failed to write shellcode to memory." << std::endl;
        return -1;
    }

    // 创建函数指针并将其指向分配的内存
    WINEXEC_SHELLCODE winExecShellcode = (WINEXEC_SHELLCODE)allocatedMemory;

    // 执行shellcode
    winExecShellcode();

    // 释放内存
    BOOL freeResult = VirtualFreeEx(
        processHandle,
        allocatedMemory,
        0,
        MEM_RELEASE);

    if (!freeResult) {
        std::cerr << "Failed to free allocated memory." << std::endl;
        return -1;
    }

    return 0;
}
