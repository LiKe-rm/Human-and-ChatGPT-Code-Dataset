#include <iostream>
#include <cstdlib>
#include <vector>
#include <binder/ProcessState.h>
#include <media/stagefright/OMXClient.h>
#include <media/IOMX.h>
#include <media/stagefright/foundation/ADebug.h>
#include <media/stagefright/foundation/AMessage.h>

using namespace android;

void fuzzIOMXQcomEnc() {
    sp<ProcessState> proc(ProcessState::self());
    OMXClient client;
    status_t err = client.connect();
    CHECK_EQ(err, (status_t)OK);

    sp<IOMX> omx = client.interface();
    IOMX::node_id node;
    const char *componentName = "OMX.qcom.video.encoder.mpeg4";

    err = omx->allocateNode(componentName, NULL, &node);
    CHECK_EQ(err, (status_t)OK);

    const size_t kNumBuffers = 4;
    const size_t kBufferSize = 1024 * 1024;
    std::vector<sp<IMemoryHeap>> heaps;

    for (size_t i = 0; i < kNumBuffers; ++i) {
        sp<MemoryHeapBase> heap = new MemoryHeapBase(kBufferSize, 0, "fuzzInput");
        heaps.push_back(heap);
        omx->useBuffer(node, 0, NULL, heap, 0, kBufferSize, NULL);
    }

    for (size_t i = 0; i < kNumBuffers; ++i) {
        sp<MemoryHeapBase> heap = new MemoryHeapBase(kBufferSize, 0, "fuzzOutput");
        heaps.push_back(heap);
        omx->useBuffer(node, 1, NULL, heap, 0, kBufferSize, NULL);
    }

    omx->sendCommand(node, OMX_CommandStateSet, OMX_StateIdle, NULL);

    for (size_t i = 0; i < kNumBuffers; ++i) {
        // Fill input buffers with fuzzed data
        void *data = heaps[i]->base();
        ssize_t bytesRead = 0; // Replace this with the actual size of the fuzzed data
        omx->emptyBuffer(node, i, data, bytesRead, 0, 0, 0);
    }

    for (size_t i = kNumBuffers; i < 2 * kNumBuffers; ++i) {
        omx->fillBuffer(node, i, NULL, heaps[i], kBufferSize, NULL);
    }

    omx->sendCommand(node, OMX_CommandStateSet, OMX_StateExecuting, NULL);

    // Cleanup
    omx->freeNode(node);
}

int main() {
    fuzzIOMXQcomEnc();
    return 0;
}
