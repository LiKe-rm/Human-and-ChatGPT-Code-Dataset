#include <iostream>
#include <windows.h>
#include <TlHelp32.h>
#include <string>
#include <cstring>

typedef HMODULE(WINAPI* pLoadLibraryA)(LPCSTR);
typedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);

struct REMOTE_DATA
{
    pLoadLibraryA LoadLibraryA;
    pGetProcAddress GetProcAddress;
    char dllPath[MAX_PATH];
};

DWORD WINAPI LoadDll(REMOTE_DATA* data)
{
    HMODULE hModule = data->LoadLibraryA(data->dllPath);
    if (!hModule)
    {
        return 0;
    }
    return 1;
}

DWORD GetTargetThreadIDFromProcName(const char* procName)
{
    DWORD threadID = 0;
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

    if (hSnap != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te;
        te.dwSize = sizeof(THREADENTRY32);

        if (Thread32First(hSnap, &te))
        {
            do
            {
                if (strcmp(procName, te.szExeFile) == 0)
                {
                    threadID = te.th32ThreadID;
                    break;
                }
            } while (Thread32Next(hSnap, &te));
        }
    }

    CloseHandle(hSnap);
    return threadID;
}

int main(int argc, char* argv[])
{
    if (argc < 3)
    {
        std::cout << "Usage: Injector.exe <process_name> <dll_path>" << std::endl;
        return 1;
    }

    const char* processName = argv[1];
    const char* dllPath = argv[2];

    DWORD threadID = GetTargetThreadIDFromProcName(processName);
    if (threadID == 0)
    {
        std::cout << "Failed to get target thread ID." << std::endl;
        return 1;
    }

    HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, threadID);
    if (!hProc)
    {
        std::cout << "Failed to open target process." << std::endl;
        return 1;
    }

    REMOTE_DATA remoteData;
    remoteData.LoadLibraryA = (pLoadLibraryA)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    remoteData.GetProcAddress = (pGetProcAddress)GetProcAddress(GetModuleHandle("kernel32.dll"), "GetProcAddress");
    strcpy_s(remoteData.dllPath, dllPath);

    LPVOID pRemoteData = VirtualAllocEx(hProc, NULL, sizeof(REMOTE_DATA), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!pRemoteData)
    {
        std::cout << "Failed to allocate memory in target process." << std::endl;
        return 1;
    }

    if (!WriteProcessMemory(hProc, pRemoteData, &remoteData, sizeof(REMOTE_DATA), NULL))
    {
        std::cout << "Failed to write to target process memory." << std::endl;
        return 1;
    }

    LPVOID pLoadDll = VirtualAllocEx(hProc, NULL, (SIZE_T)LoadDll, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!pLoadDll)
    {
        std::cout << "Failed to allocate memory for loader code in target process." << std::endl;
        return 1;
    }

    if (!WriteProcessMemory(hProc, pLoadDll, (void*)LoadDll, (SIZE_T)LoadDll, NULL))
    {
        std::cout << "Failed to write loader code to target process memory." << std::endl;
        return 1;
    }

    HANDLE hThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadDll, pRemoteData, 0, NULL);
    if (!hThread)
    {
        std::cout << "Failed to create remote thread in target process." << std::endl;
        return 1;
    }

    WaitForSingleObject(hThread, INFINITE);

    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);
    if (exitCode == 0)
    {
        std::cout << "Failed to load DLL in target process." << std::endl;
    } else
    {
        std::cout << "DLL successfully injected!" << std::endl;
    }

    VirtualFreeEx(hProc, pRemoteData, 0, MEM_RELEASE);
    VirtualFreeEx(hProc, pLoadDll, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProc);

    return 0;
}
