#include <cstdint>
#include <cstring>
#include "ecrypt-sync.h"

#define ROTR32(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
#define ROTL32(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
#define G(x, y) ((ROTR32((x), 10) ^ ROTR32((y), 23)) + Q[((x) ^ (y)) & 0x3FF])
#define H(x, y) ((ROTL32((x), 10) ^ ROTL32((y), 23)) + P[((x) ^ (y)) & 0x3FF])

#define step_P(p, q)              \
  do {                            \
    P[(p)] += G(P[(p)-3], P[(p)-2]); \
    (q) = P[(p)] ^ H(P[(p)-1], P[(p)-3]); \
  } while (0)

#define step_Q(p, q)              \
  do {                            \
    Q[(p)] += H(Q[(p)-3], Q[(p)-2]); \
    (q) = Q[(p)] ^ G(Q[(p)-1], Q[(p)-3]); \
  } while (0)

static uint32_t P[1024], Q[1024];

static void generate_keystream(uint32_t keystream[16]) {
	for (int i = 0; i < 16; ++i) {
		step_P(256 + i, keystream[i]);
	}
}

void ECRYPT_init() {}

void ECRYPT_keysetup(ECRYPT_ctx* ctx, const u8* key, u32 keysize, u32 ivsize) {
	ctx->keysize = keysize;
	ctx->ivsize = ivsize;
	memcpy(ctx->key, key, keysize / 8);
}

void ECRYPT_ivsetup(ECRYPT_ctx* ctx, const u8* iv) {
	uint32_t W[2560];
	for (int i = 0; i < 8; ++i) {
		W[i] = U8TO32_LITTLE(ctx->key + 4 * i);
		W[i + 8] = U8TO32_LITTLE(iv + 4 * i);
	}
	for (int i = 16; i < 2560; ++i) {
		W[i] = W[i - 2] + ROTR32(W[i - 7], 17) + ROTR32(W[i - 15], 7) + W[i - 16] + i;
	}
	memcpy(P, W + 512, sizeof(P));
	memcpy(Q, W + 1536, sizeof(Q));
	for (int i = 0; i < 512; ++i) {
		uint32_t tmp;
		step_P(i, tmp);
	}
	for (int i = 0; i < 512; ++i) {
		uint32_t tmp;
		step_Q(i, tmp);
	}
	ctx->counter = 0;
}

void ECRYPT_process_bytes(int action, ECRYPT_ctx* ctx, const u8* input, u8* output, u32 msglen) {
	u32 keystream[16];
	u32 i;
	for (i = 0; i < msglen / 64; ++i) {
		generate_keystream(keystream);
		for (u32 j = 0; j < 16; ++j) {
			U32TO8_LITTLE
			(output + 4 * j) = U32TO8_LITTLE(input + 4 * j) ^ U32TO8_LITTLE(keystream[j]);
		}
		input += 64;
		output += 64;
		ctx->counter++;
	}

	if (msglen % 64) {
		generate_keystream(keystream);
		for (i = 0; i < (msglen % 64) / 4; ++i) {
			U32TO8_LITTLE(output + 4 * i) = U32TO8_LITTLE(input + 4 * i) ^ U32TO8_LITTLE(keystream[i]);
		}
		for (i = (msglen % 64) / 4 * 4; i < msglen % 64; ++i) {
			output[i] = input[i] ^ U8V(keystream[i / 4] >> (8 * (i % 4)));
		}
	}
}

void ECRYPT_encrypt_bytes(ECRYPT_ctx* ctx, const u8* plaintext, u8* ciphertext, u32 msglen) {
	ECRYPT_process_bytes(0, ctx, plaintext, ciphertext, msglen);
}

void ECRYPT_decrypt_bytes(ECRYPT_ctx* ctx, const u8* ciphertext, u8* plaintext, u32 msglen) {
	ECRYPT_process_bytes(1, ctx, ciphertext, plaintext, msglen);
}