#include <iostream>
#include <string>
#include <filesystem>
#include <fstream>
#include <vector>
#include <algorithm>

#include "curve25519-donna.h"
#include "sosemanuk.h"
#include "sha256.h"

namespace fs = std::filesystem;

const std::string encrypted_extension = ".babyk";
const std::string ransom_note_name = "How To Restore Your Files.txt";
const int block_size = 4096;

bool decrypt_file(const std::string& file_path) {
    std::ifstream encrypted_file(file_path, std::ios::binary);
    if (!encrypted_file) {
        return false;
    }

    // Read the last 32 bytes for the public key
    encrypted_file.seekg(-32, std::ios::end);
    std::vector<unsigned char> public_key(32);
    encrypted_file.read(reinterpret_cast<char*>(public_key.data()), 32);

    // Calculate the shared secret using Curve25519
    std::vector<unsigned char> private_key(32);
    std::vector<unsigned char> shared_secret(32);
    curve25519_donna(shared_secret.data(), private_key.data(), public_key.data());

    // Hash the shared secret with SHA256 to get the key for the stream cipher
    std::vector<unsigned char> hash_key(32);
    sha256(shared_secret.data(), 32, hash_key.data());

    // Initialize Sosemanuk with the hash key
    sosemanuk_key_context kc;
    sosemanuk_iv_context ic;
    sosemanuk_schedule(&kc, hash_key.data(), 32);

    // Prepare to read and decrypt the file in blocks
    encrypted_file.seekg(0, std::ios::beg);
    std::ofstream decrypted_file(file_path + ".decrypted", std::ios::binary);
    std::vector<unsigned char> buffer(block_size);

    while (!encrypted_file.eof()) {
        encrypted_file.read(reinterpret_cast<char*>(buffer.data()), block_size);
        std::streamsize bytes_read = encrypted_file.gcount();
        sosemanuk_run(&kc, &ic, buffer.data(), buffer.data(), bytes_read);
        decrypted_file.write(reinterpret_cast<char*>(buffer.data()), bytes_read);
    }

    encrypted_file.close();
    decrypted_file.close();

    // Remove the encrypted file and rename the decrypted file
    fs::remove(file_path);
    fs::rename(file_path + ".decrypted", file_path.substr(0, file_path.size() - encrypted_extension.size()));

    return true;
}

void find_files_recursive(const fs::path& directory) {
    for (const auto& entry : fs::directory_iterator(directory)) {
        if (entry.is_regular_file()) {
            if (entry.path().extension() == encrypted_extension) {
                decrypt_file(entry.path().string());
            } else if (entry.path().filename() == ransom_note_name) {
                fs::remove(entry.path());
            }
        } else if (entry.is_directory()) {
            find_files_recursive(entry.path());
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <root_directory>" << std::endl;
        return 1;
    }

    fs::path root_directory(argv[1]);
    if (!fs::is_directory(root_directory)) {
        std::cerr << "Error: " << root_directory.string() << " is not a directory" << std::endl;
        return 1;
    }

    find_files_recursive(root_directory);

    std::cout << "Decryption process completed." << std::endl;

    return 0;
}
