#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <chrono>
#include <algorithm>
#include <cstdint>
#include <cstring>
#include <ctime>
#include <openssl/md5.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

using namespace std;

struct bot_t {
    int sockfd;
    string ip;
};

struct bot_list_t {
    vector<bot_t> bots;
    mutex m;
};

void add_authorized_ip(vector<string>& authorized_ips, const string& ip) {
    authorized_ips.push_back(ip);
}

void remove_authorized_ip(vector<string>& authorized_ips, const string& ip) {
    authorized_ips.erase(remove(authorized_ips.begin(), authorized_ips.end(), ip), authorized_ips.end());
}

void show_authorized_ips(const vector<string>& authorized_ips) {
    for (const auto& ip : authorized_ips) {
        cout << ip << endl;
    }
}

string md5_hash_file(const string& file_path) {
    unsigned char digest[MD5_DIGEST_LENGTH];
    ifstream file(file_path, ifstream::binary);
    if (!file) {
        cerr << "Failed to open file: " << file_path << endl;
        return "";
    }

    MD5_CTX ctx;
    MD5_Init(&ctx);
    char buf[1024];
    while (file.read(buf, sizeof(buf))) {
        MD5_Update(&ctx, buf, file.gcount());
    }
    MD5_Final(digest, &ctx);
    file.close();

    stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << hex << (int)digest[i];
    }

    return ss.str();
}

void check_file_integrity(const string& file_path, string& stub_data) {
    string hash = md5_hash_file(file_path);
    if (hash.empty()) {
        stub_data.clear();
    } else {
        cout << "File hash: " << hash << endl;
    }
}

void handle_bot_connections(bot_list_t& bot_list, int port, vector<string>& authorized_ips) {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    while (true) {
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }
        char ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &(address.sin_addr), ip, INET_ADDRSTRLEN);
        string ip_str(ip);

        if (find(authorized_ips.begin(), authorized_ips.end(), ip_str) != authorized_ips.end()) {
            bot_t new_bot;
            new_bot.sockfd = new_socket;
            new_bot.ip = ip_str;
            bot_list.m.lock();
            bot_list.bots.push_back(new_bot);
            bot_list.m.unlock();

            cout << "New bot connected: " << ip_str << endl;
        } else {
            cout << "Unauthorized IP tried to connect: " << ip_str << endl;
            close(new_socket);
        }
    }

}

void handle_control_server_connections(bot_list_t& bot_list, int port, vector<string>& authorized_ips) {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    while (true) {
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        // Handle control server connection and process commands
        // ...

        close(new_socket);
    }
}
